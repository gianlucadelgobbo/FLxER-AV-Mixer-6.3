/* STRUTTURA CLIP 	effects	cnt		bkg			SHAPE		cnt w/2 h/2			myVideo -w/2 -h/2			swfLoader -w/2 -h/2			imgLoader0 -w/2 -h/2			imgLoader1 -w/2 -h/2	cntMask w/2 h/2		trgtMask -w/2 -h/2		baseMask			SHAPE -w/2 -h/2*/package FLxER.core {	import flash.display.AVM1Movie;	import flash.display.DisplayObject;	import flash.display.Loader;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.display.StageQuality;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.NetStatusEvent;	import flash.events.ProgressEvent;	import flash.events.SecurityErrorEvent;	import flash.filters.ColorMatrixFilter;	import flash.geom.ColorTransform;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.SoundLoaderContext;	import flash.media.SoundMixer;	import flash.media.SoundTransform;	import flash.media.Video;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.net.URLLoader;	import flash.net.URLLoaderDataFormat;	import flash.net.URLRequest;	import flash.system.ApplicationDomain;	import flash.system.LoaderContext;	import flash.system.Security;	import flash.system.SecurityDomain;	import flash.text.TextFormat;	import flash.utils.clearInterval;	import flash.utils.setInterval;	import flash.xml.XMLDocument;		import FLxER.core.ColorMatrix;		import fl.transitions.Tween;	import fl.transitions.TweenEvent;	import fl.transitions.easing.Strong;
	//import flash.utils.*;	public class Player extends Sprite {		public var ch:Number;		private var w:Number;		private var h:Number;		public var xx:Number;		public var yy:Number;		public var zz:Number;		public var myStopStatus:Boolean;		private var oldTipo:String;		private var newFlv:Boolean;		private var myDuration:Number;		private var frameRate:Number;		private var myWidth:Number;		private var myHeight:Number;		private var imgToShow:Loader;		private var imgToRemove:Loader;		private var myTweenA:Tween;		private var myTweenS:Tween;		private var song:SoundChannel;		private var sliderVal:Number;		private var myTxt:String;		private var intTime:Number;		private var myFont:String;		private var txtKS:TextFormat;				// CLIPS CONTAINERS		private var bkg:Sprite;		private var cnt:Sprite;		public var vid:Sprite;		private var myVideo:Video;				//public var 		;		public var imgLoader0:Loader;		public var imgLoader1:Loader;		public var cntMask:Sprite;		public var baseMask:Sprite;		public var trgtMask:Sprite;		public var oldMask:Sprite;		// END CLIPS CONTAINERS		// OBJECTS		private var NC:NetConnection;		public var NS:NetStream;		private var customClient:Object;		public var swfLoader:Loader;		private var wipesLoader:Loader;		private var swfSound:SoundMixer;		private var transformSound:SoundTransform;		private var flvSound:SoundMixer;		public var mp3Sound:Sound;		private var CFT:Object;		private var CMT:Object;				// END OBJECTS		private var seqInt:uint;		private var seqPos:Number;		private var seqPattern:Array;		private var masterSeq:Boolean;		public var seqStatus:Boolean;		private var needToRedrawMask:Boolean;		private var trgtListener:*;		private var myCamera:int;		private var stereo:String;				private var urlLoader:URLLoader				public var audioEnabled:Boolean				public function Player(a:uint, ww:uint, hh:uint,t:*,s="center",aa=false):void {			trgtListener = t			seqPos = -1;			ch = a;			w = ww;			h = hh;			myStopStatus = false;			stereo = s;			audioEnabled = aa;						// PLAYER CLIPS			cnt = new Sprite();			addChild(cnt);					//			bkg = new Sprite();            bkg.graphics.beginFill(0xFFFFFF);            bkg.graphics.drawRect(0, 0, w, h);            bkg.graphics.endFill();            cnt.addChild(bkg);			bkg.visible = false;			//			vid = new Sprite();            cnt.addChild(vid);			//			cntMask = new Sprite();			addChild(cntMask);						baseMask = new Sprite();            baseMask.graphics.beginFill(0xFFFFFF);            baseMask.graphics.drawRect(-w/2, -h/2, w, h);            baseMask.graphics.endFill();            cntMask.addChild(baseMask);			needToRedrawMask = false;			trgtMask = new Sprite();			vid.x = cntMask.x = w/2;			vid.y = cntMask.y = h/2;			cnt.mask = cntMask;			// END PLAYER CLIPS						NC = new NetConnection();			NC.addEventListener(NetStatusEvent.NET_STATUS, NCHandler);			NC.connect(null);			swfLoader = new Loader();			swfLoader.contentLoaderInfo.addEventListener(Event.INIT, initHandlerSWF);			swfLoader.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandlerSWF);			swfLoader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, errorHandlerSWF);			wipesLoader = new Loader();			wipesLoader.contentLoaderInfo.addEventListener(Event.INIT, initHandlerWipes);            wipesLoader.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandlerWipes);            wipesLoader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, errorHandlerWipes);			/*			flvSound = new SoundMixer();			swfSound = new SoundMixer();			swfChannel = swfSound.play();			transformSound = swfChannel.soundTransform;            transformSound.volume = 0;            swfChannel.soundTransform = transformSound;			*/			transformSound = new SoundTransform();			bkg.transform.colorTransform = new ColorTransform(1, 1, 1, 1, -255, -255, -255, 1);			myFont = Preferences.myFont;			/*txtKS = new TextFormat();			txtKS.font = myFont;			txtKS.size = 48;			txtKS.color = 0x00000;			txtKS.align = "center";*/		}		public function resizer():void {			w = Preferences.pref.monObj.monWidth;			h = Preferences.pref.monObj.monHeight;			vid.x = cntMask.x = Preferences.interfaceTrgt.chCnt["ch_"+ch].myTrasform.x_m.myStart = Preferences.interfaceTrgt.chCnt["ch_"+ch].myTrasform.x_m.myDelta = w/2;			vid.y = cntMask.y = Preferences.interfaceTrgt.chCnt["ch_"+ch].myTrasform.y_m.myStart = Preferences.interfaceTrgt.chCnt["ch_"+ch].myTrasform.y_m.myDelta = h/2;			Preferences.interfaceTrgt.chCnt["ch_"+ch].myTrasform.x_m.val = vid.x;			Preferences.interfaceTrgt.chCnt["ch_"+ch].myTrasform.y_m.val = vid.y;			if (cntMask.contains(wipesLoader)) {				resizerSwf(wipesLoader)			//} else if (drawMask.numChildren == 0){			} else if (cntMask.contains(baseMask)){				baseMask.graphics.clear();				baseMask.graphics.beginFill(0xFFFFFF);				baseMask.graphics.drawRect(-w/2, -h/2, w, h);				baseMask.graphics.endFill();			}			bkg.graphics.clear();			bkg.graphics.beginFill(0xFFFFFF);			bkg.graphics.drawRect(0, 0, w, h);			bkg.graphics.endFill();			if (oldTipo == "swf") {				resizerSwf(swfLoader)			} else if (oldTipo == "flv") {				resizerFlv()			} else if (oldTipo == "jpg") {				resizerSwf(imgToShow);			}		}		// SWF LOADER		public function changeFps(myAction:Array):void {			stage.frameRate = myAction[3];		}		public function loadMedia(myAction:Array):void {			trace("Load media:")			Preferences.deepTrace(myAction)			if ((myAction[3].slice(-3,myAction[3].length)).toLowerCase()=="swf" ) {				if (oldTipo != null) {					this["RESET"+oldTipo]();				}				oldTipo = myAction[4];				myTxt = "";				myCamera = -1;				if (myAction.length > 8) {					intTime = parseInt(myAction[7]);					myTxt = (myAction[6] ? Preferences.myReplace(Preferences.myReplace(myAction[6],"txt=",""),"###§###",",") : undefined);				} else if (myAction[6]) {					trace("setmyCameraAAAA "+myAction[7])					myCamera = parseInt(myAction[7]);					trace("setmyCameraAAAA "+myCamera)				}				sliderVal = parseFloat(myAction[5])/100;				trace(Security.sandboxType)				trace(Security.REMOTE)				if (Security.sandboxType==Security.REMOTE) {					var context:LoaderContext = new LoaderContext(true, ApplicationDomain.currentDomain, SecurityDomain.currentDomain);					context.allowCodeImport = true;					//swfLoader.load(new URLRequest(myAction[3]), context);					swfLoader.load(new URLRequest(myAction[3]), context);				} else {					urlLoader = new URLLoader();					urlLoader.dataFormat = URLLoaderDataFormat.BINARY;					urlLoader.addEventListener(Event.COMPLETE, bytesLoadedd);					// cross-domain policy file required to load data					//urlLoader.load(new URLRequest(myAction[3]));					urlLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandlerSWF);					urlLoader.addEventListener(IOErrorEvent.IO_ERROR, errorHandlerSWF);					urlLoader.load(new URLRequest(myAction[3]));				}			} else {				loadImg(myAction)			}		}		private function bytesLoadedd(event:Event):void {			trace("bytesLoadedd")			var context:LoaderContext = new LoaderContext();			context.allowCodeImport = true;			if (urlLoader.data) swfLoader.loadBytes(urlLoader.data, context);		}		private function resizerSwf(t:Loader):void {			if (Preferences.pref.resizzaMode) {							if (Preferences.pref.resizzaMode==2) {								if (w/h > t.contentLoaderInfo.width/t.contentLoaderInfo.height) {						t.scaleX = w/t.contentLoaderInfo.width;						t.scaleY = t.scaleX;					} else {						t.scaleY = h/t.contentLoaderInfo.height;						t.scaleX = t.scaleY;					}				} else  {					if (w/h < t.contentLoaderInfo.width/t.contentLoaderInfo.height) {						t.scaleX = w/t.contentLoaderInfo.width;						t.scaleY = t.scaleX;					} else {						t.scaleY = h/t.contentLoaderInfo.height;						t.scaleX = t.scaleY;					}				}			} else  {				t.scaleY = t.scaleX = 1;			}			if (Preferences.centra_onoff) {							t.x = -(t.contentLoaderInfo.width*t.scaleX)/2;				t.y = -(t.contentLoaderInfo.height*t.scaleY)/2;			} else {				t.x = -w/2;				t.y = -h/2;			}		}		private function initHandlerSWF(event:Event):void {			myWidth = swfLoader.contentLoaderInfo.width;			myHeight = swfLoader.contentLoaderInfo.height;			//trace(swfLoader.contentLoaderInfo.width)			//trace(swfLoader.contentLoaderInfo.height)			if(swfLoader.content is AVM1Movie) {				if (myStopStatus) {					STOP(null);				}			}			if (!vid.contains(swfLoader)) {				vid.addChild(swfLoader);			}			trace("trymyCameramy "+myCamera)			if (myCamera>=0) {				try {					trace("trymyCameramyCameramyCameramyCameramyCameramyCameramyCameramyCamera")					//var swfLoader.content.startCamera:Function;					swfLoader.content["startCamera"](myCamera);				}				catch(e) {					trace("catchmyCameramyCameramyCameramyCameramyCameramyCameramyCameramyCamera")					trace(e)				}			}			if (myTxt) {				txtKS = swfLoader.content["myTextFormat"];				swfLoader.content["startReader"](myTxt, intTime);				swfLoader.content["lab"].x = -400+200;				swfLoader.content["lab"].y = 100;				swfLoader.content["lab"].width = 1200;				swfLoader.content["lab"].height = 100;				ALIGNtxt([null,null,null,txtKS.align]);			}			resizerSwf(swfLoader)			trgtListener["initHandlerSWF"](swfLoader, ch);			setVolAct(sliderVal);		}		private function errorHandlerSWF(event:Event):void {			trgtListener.errorHandlerSWF(event, ch);		}		private function RESETswf():void {			if (vid.contains(swfLoader)) {				swfLoader.unloadAndStop();				vid.removeChild(swfLoader);			}		}		public function SCRATCH(myAction:Array):void {			this["SCRATCH"+oldTipo](myAction);		}		private function SCRATCHswf(myAction:Array):void {			if(swfLoader.content is MovieClip) {				var tmp:String				if (myStopStatus) {					tmp = "gotoAndStop";				} else {					tmp = "gotoAndPlay";				}				swfLoader.content[tmp](int(((swfLoader.content["totalFrames"]-1)*parseFloat(myAction[3]))+1));			}		}		private function REWINDswf():void {			if (myTxt) {				swfLoader.content["myRewind"]();			} else if(swfLoader.content is MovieClip) {				var act:String;				if (myStopStatus) {					act = "gotoAndStop";				} else {					act = "gotoAndPlay";				}				recursiveSwfActParam(swfLoader.content, act, 1);			}		}		private function FORWARDswf():void {			if(swfLoader.content is MovieClip) {				var act:String;				if (myStopStatus) {					act = "gotoAndStop";				} else {					act = "gotoAndPlay";				}				recursiveSwfActParam(swfLoader, act, int(swfLoader["currentFrame"]+((swfLoader["totalFrames"]-swfLoader["currentFrame"])/2)));			}		}		private function STOPswf():void {			trace(swfLoader.content)			if (myTxt) {				swfLoader.content["myStop"]();			} else if(swfLoader.content is MovieClip) {				recursiveSwfAct(swfLoader.content, "stop");			}		}		private function PLAYswf():void {			if (myTxt) {				swfLoader.content["myPlay"]();			} else if(swfLoader.content is MovieClip) {				recursiveSwfAct(swfLoader.content, "play");			}		}		private function recursiveSwfAct(trgt:*, act:String):void {			trgt[act]();			for (var a:int=0;a<trgt.numChildren;a++) {				if (trgt.getChildAt(a) is MovieClip) {					trgt.getChildAt(a)[act]();					recursiveSwfAct(trgt.getChildAt(a), act);				}			}		}		private function recursiveSwfActParam(trgt:*, act:String, p:uint):void {			trgt[act](p);			var item:DisplayObject;			trace(act)			for (item in trgt) {				trace(item)				trace(trgt[item])				if (trgt[item].totalFrames) {					trgt[item][act](p);					recursiveSwfActParam(trgt[item], act, p);				}			}		}		// END SWF LOADER		// VIDEO LOADER		public function loadFlv(myAction:Array):void {			trace("loadFlv "+myAction[3])			if (oldTipo != null) {				this["RESET"+oldTipo]();			}			oldTipo = "flv";			newFlv = true			NS.play(myAction[3]);			NS.pause();			trace("loadFlv"+parseFloat(myAction[5])/100)			setVolAct(parseFloat(myAction[5])/100);		}		public function NCHandler(event:NetStatusEvent):void {			switch (event.info.code) {				case "NetConnection.Connect.Success" :					connectStream();					break;			}		}		public function connectStream():void {			NS = new NetStream(NC);			NS.bufferTime = 2;			customClient = new Object();			customClient.onMetaData = onMetaData;			//customClient.onCuePoint = onCuePoint;			//customClient.onPlayStatus = onPlayStatus;			NS.client = customClient;			NS.addEventListener(NetStatusEvent.NET_STATUS, NSHandler);		}		public function NSHandler(event:NetStatusEvent):void {			trace(event.info.code)			//if (event.info.code == "NetStream.Play.Stop") {			if (event.info.code == "NetStream.Buffer.Empty") {				if (Preferences.myLoop) {					NS.seek(0);				} else {					trgtListener.initHandlerFLV(event, ch)				}			}			if (event.info.code == "NetStream.Play.Start") {				if (myStopStatus) {					NS.pause();					//NS.seek(0);				}				// SOLO SUPERPLAYER //				trgtListener.initHandlerFLV(event, ch)			}			if (event.info.code == "NetStream.Buffer.Full") {				trgtListener.initHandlerFLV(event, ch)			}			if (event.info.code == "NetStream.Play.StreamNotFound" || event.info.code == "NetStream.Play.FileStructureInvalid"|| event.info.code == "NetStream.Play.NoSupportedTrackFound") {				trgtListener.errorHandlerFLV(event, ch)			}		}		private function resizerFlv():void {			if (Preferences.pref.resizzaMode) {							if (Preferences.pref.resizzaMode==2) {						if (w/h > myWidth/myHeight) {						myVideo.width = w;						myVideo.scaleY = myVideo.scaleX;					} else {						myVideo.height = h;						myVideo.scaleX = myVideo.scaleY;					}				} else {					if (w/h < myWidth/myHeight) {						myVideo.width = w;						myVideo.scaleY = myVideo.scaleX;					} else {						myVideo.height = h;						myVideo.scaleX = myVideo.scaleY;					}				}			} else {				myVideo.width = myWidth;				myVideo.height = myHeight;			}			if (Preferences.centra_onoff) {							myVideo.x = -myVideo.width/2;				myVideo.y = -myVideo.height/2;			} else {				myVideo.x = -w/2;				myVideo.y = -h/2;			}		}		public function onMetaData(info:Object):void {			if (newFlv) {				if (Preferences.myBufferType=="perc") {					NS.bufferTime = Preferences.myBufferTimeVal*info.duration;				} else if (Preferences.myBufferType=="val") {					NS.bufferTime = Preferences.myBufferTimeVal;				} else {					NS.bufferTime = 2;				}				trace("metadata: duration=" + info.duration + " width=" + info.width + " height=" + info.height + " framerate=" + info.framerate)				if (!myStopStatus) {					NS.resume();				}				myDuration = info.duration;				myWidth = info.width;				myHeight = info.height;				frameRate = info.framerate;				//				myVideo = new Video(info.width , info.height);				myVideo.smoothing = true;				myVideo.attachNetStream(NS);				if (!vid.contains(myVideo)) {					vid.addChild(myVideo);				}				resizerFlv()				newFlv = false			}		}		private function REWINDflv():void {			NS.seek(0);		}		private function FORWARDflv():void {			var tmp2:int = int((NS.time)+(myDuration/10));			if (tmp2>myDuration) {				tmp2 = myDuration;			}			NS.seek(tmp2);		}		private function SCRATCHflv(myAction:Array):void {			trace("SCRATCHflv 1 "+myAction[3])			trace("SCRATCHflv 2 "+myDuration)			NS.seek((myDuration*parseFloat(myAction[3])));			NS.resume();		}		private function STOPflv():void {			NS.pause();		}		private function PLAYflv():void {			NS.resume();		}		private function RESETflv():void {			NS.close();			if (myVideo is Video) {				if (vid.contains(myVideo)) {					myVideo.clear();					vid.removeChild(myVideo);				}			}		}		// END VIDEO LOADER				// IMAGES LOADER		public function loadImg(myAction:Array):void {			if (oldTipo != null && oldTipo != "jpg") {				this["RESET"+oldTipo]();			}			oldTipo = "jpg";			/* SOLO SUPERPLAYER 			loadPicAction = myAction;			var contextTmp = false;			if (Preferences.policyFile) {				Security.loadPolicyFile(Preferences.policyFile);				contextTmp = true;			}			var context = new LoaderContext(contextTmp);*/			if (imgLoader0 == null) {				imgLoader0 = new Loader();			}			if (imgLoader1 == null) {				imgLoader1 = new Loader();							}			//imgLoader0.alpha = imgLoader1.alpha = 0;			vid.addChild(imgLoader0)			vid.addChild(imgLoader1)			if (imgLoader0.content == null) {				imgLoader0.contentLoaderInfo.addEventListener(Event.INIT, initHandlerJPG);				imgLoader0.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandlerJPG);				imgLoader0.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, errorHandlerJPG);				imgToShow = imgLoader0;				imgLoader0.load(new URLRequest(myAction[3])/*, context*/);			} else {				imgLoader1.contentLoaderInfo.addEventListener(Event.INIT, initHandlerJPG);				imgLoader1.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandlerJPG);				imgLoader1.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, errorHandlerJPG);				imgToShow = imgLoader1;				imgLoader1.load(new URLRequest(myAction[3])/*, context*/);			}		}		private function initHandlerJPG(event:Event):void {			myWidth = imgToShow.contentLoaderInfo.width;			myHeight = imgToShow.contentLoaderInfo.height;			resizerSwf(imgToShow);			if (imgToRemove != null) {				resizerSwf(imgToRemove);				myFadeOff();			} else {				myFadeOn();			}			trgtListener.initHandlerJPG(imgToShow,ch);        }		private function errorHandlerJPG(event:Event):void {			trgtListener.errorHandlerJPG(event,ch);		}		private function myFadeOff():void {			myFadeOn()			myTweenS=new Tween(imgToRemove,"alpha",Strong.easeIn,1,0,.5,true);			myTweenS.useSeconds = true;			myTweenS.addEventListener(TweenEvent.MOTION_FINISH, myFadeOffFinish);        }		private function myFadeOffFinish(event:Event):void {			imgToRemove.unload()			myTweenS.removeEventListener(TweenEvent.MOTION_FINISH, myFadeOffFinish);        }		private function myFadeOn():void {			// SOLO SUPERPLAYER //			myTweenA = new Tween(imgToShow,"alpha",Strong.easeIn,0,1,1,true);			myTweenA.useSeconds = true;			myTweenA.addEventListener(TweenEvent.MOTION_FINISH, myFadeOnFinish);        }		private function myFadeOnFinish(event:Event):void {			// SOLO SUPERPLAYER //			trgtListener.initHandlerJPG(imgToShow, ch);			imgToRemove = imgToShow;			myTweenA.removeEventListener(TweenEvent.MOTION_FINISH, myFadeOnFinish);        }		private function RESETjpg():void {			imgToRemove = null;			imgToShow = null;			if (imgLoader0) {				imgLoader0.unload();			}			if (imgLoader1) {				imgLoader1.unload();			}			if (myTweenA) {				myTweenA.stop()				myTweenA.removeEventListener(TweenEvent.MOTION_FINISH, myFadeOnFinish);			}			if (myTweenS) {				myTweenS.stop()				myTweenS.removeEventListener(TweenEvent.MOTION_FINISH, myFadeOffFinish);			}			if (imgLoader0 is Loader) {				if (vid.contains(imgLoader0)) {					vid.removeChild(imgLoader0);	//				imgLoader0 = null;				}			}			if (imgLoader1 is Loader) {				if (vid.contains(imgLoader1)) {					vid.removeChild(imgLoader1);	//				imgLoader1 = null;				}			}		}		public function PLAYjpg():void {			trace("PLAYjpg");		}		// SOLO SUPERPLAYER //		/*		public function STOPjpg():void {		}		public function PLAYjpg():void {			Preferences.interfaceTrgt.load_foto()		}		public function REWINDjpg():void {			//myStopStatus = true;			Preferences.interfaceTrgt.load_prev_foto()		}		public function FORWARDjpg():void {			//myStopStatus = true;			Preferences.interfaceTrgt.load_foto()		}		*/		// END IMAGES LOADER		// MP3 LOADER		public function loadMp3(myAction:Array):void {			if (oldTipo != null) {				this["RESET"+oldTipo]();			}			oldTipo = "mp3";			var slc:SoundLoaderContext = new SoundLoaderContext(1, false); 			mp3Sound = new Sound();			mp3Sound.addEventListener(Event.COMPLETE, soundCompleteHandler);			mp3Sound.addEventListener(flash.events.ProgressEvent.PROGRESS, soundProgressHandler);			mp3Sound.addEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandlerMP3);			mp3Sound.addEventListener(IOErrorEvent.IO_ERROR, errorHandlerMP3);			mp3Sound.load(new URLRequest(myAction[3]),slc);			song = mp3Sound.play(0,1, transformSound);			song.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler2);			setVolAct(parseFloat(myAction[5])/100);			if (myStopStatus) {				song.stop();			}			// SOLO SUPERPLAYER //			trgtListener.initHandlerMP3(ch)			if (myAction[6]) {				imgLoader0 = new Loader();				imgLoader0.x = -w/2;				imgLoader0.y = -h/2;				imgToShow = imgLoader0;				//imgLoader0.alpha = 0;				vid.addChild(imgLoader0)				imgLoader0.contentLoaderInfo.addEventListener(Event.INIT, initHandlerJPG);				imgLoader0.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandlerJPG);				imgLoader0.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, errorHandlerJPG);				imgLoader0.load(new URLRequest(myAction[6]));			}		}		private function errorHandlerMP3(event:Event):void {			trgtListener.errorHandlerMP3(event, ch)		}		private function soundProgressHandler(event:Event):void {			trace("soundProgressHandler "+mp3Sound.bytesLoaded)		}		private function soundCompleteHandler(event:Event):void {		}		private function soundCompleteHandler2(event:Event):void {            transformSound.volume = (audioEnabled ? sliderVal : 0);			song = mp3Sound.play(0,1, transformSound);			song.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler2);		}		public function setVol(myAction:Array):void {			trace("setVol "+myAction)			setVolAct(parseFloat(myAction[3]));		}		private function setVolAct(v:Number):void {			sliderVal = v;			transformSound.volume = (audioEnabled ? sliderVal : 0);			trace("setVolAct "+audioEnabled+" "+v)			if (oldTipo == "flv") {				NS.soundTransform = transformSound;			} else if (oldTipo == "swf") {				swfLoader.parent["soundTransform"] = transformSound;			} else if (oldTipo == "mp3") {				song.soundTransform = transformSound;			}		};		private function RESETmp3():void {			trace("mp3Reset")			song.stop();			RESETjpg();		}		private function REWINDmp3():void {			song.stop();			soundCompleteHandler2(null);		}		private function FORWARDmp3():void {			song.stop();			song = mp3Sound.play(song.position+((mp3Sound.length-song.position)/10));			song.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler2);		}		private function SCRATCHmp3(myAction:Array):void {			var tmp:int = (((mp3Sound.length)*(parseFloat(myAction[3])/800)))/1000;			song.stop();			song = mp3Sound.play(parseFloat(myAction[3])*mp3Sound.length);			song.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler2);		}		private function STOPmp3():void {			song.stop();		}		private function PLAYmp3():void {			song = mp3Sound.play(song.position);			song.addEventListener(Event.SOUND_COMPLETE, soundCompleteHandler2);		}		// END MP3 LOADER		// WIPES LOADER		public function changeWipe(myAction:Array):void {			cntMask.graphics.clear();			if (cntMask.contains(baseMask)) {				cntMask.removeChild(baseMask);			}			trace("wipesLoader "+myAction[3])			wipesLoader.load(new URLRequest(myAction[3]))		}		public function restoreMask():void {			if (oldMask) {				cntMask.addChild(oldMask);			}		}		public function clearMask(myAction:Array):void {			if (!cntMask.contains(baseMask)) {				cntMask.addChild(baseMask);			}			if (cntMask.contains(trgtMask)) {				cntMask.removeChild(trgtMask);			}			needToRedrawMask = true;			baseMask.graphics.clear();		}		private function initHandlerWipes(event:Event):void {			//trgtMask = null;			if (!cntMask.contains(trgtMask)) {				cntMask.addChild(trgtMask);			}			trgtMask.addChild(wipesLoader);			resizerSwf(wipesLoader)		}		private function errorHandlerWipes(event:Event):void {			redrawWipe(null);			trgtListener.errorHandlerWipes(event, ch);		}		public function redrawWipe(myAction:Array):void {			if (trgtMask) {				if (cntMask.contains(trgtMask)) {					wipesLoader.unload();					cntMask.removeChild(trgtMask);				}			}			if (!cntMask.contains(baseMask)) {				cntMask.addChild(baseMask);			}			alpha = 1;			if (needToRedrawMask) {				baseMask.graphics.clear();				baseMask.graphics.beginFill(0xFFFFFF);				baseMask.graphics.drawRect(-w/2, -h/2, w, h);				baseMask.graphics.endFill();				needToRedrawMask = false;			}			/**/		}		public function slideWipe(myAction:Array):void {			trace("setVol"+myAction[3])			setVolAct(parseFloat(myAction[3])/100);			if (oldTipo == "mp3") {			}			if (myAction[4] == "WIPE NONE (MIX)") {				cntMask.scaleX = 1;				cntMask.scaleY = 1;				alpha = myAction[3]/100;			} else if (myAction[4] == "HORIZONTAL") {				cntMask.scaleX = myAction[3]/100;				cntMask.scaleY = 1;				alpha = 1;			} else if (myAction[4] == "VERTICAL") {				cntMask.scaleX = 1;				cntMask.scaleY = myAction[3]/100;				alpha = 1;			} else {				cntMask.scaleX = myAction[3]/100;				cntMask.scaleY = myAction[3]/100;				alpha = 1;			}		}		public function useMap(myAction):void {			trace("useMapuseMapuseMapuseMapuseMapuseMapuseMap\n"+myAction[3]);			clearMask(myAction);			var xmlMap:XMLDocument = new XMLDocument();			xmlMap.ignoreWhite = true;			xmlMap.parseXML(myAction[3]);			for (var a:int=0;a<xmlMap.childNodes[0].childNodes[0].childNodes.length;a++) {				var forma:Array = xmlMap.childNodes[0].childNodes[0].childNodes[a].attributes.d.substring(1).split("Q");				forma[0] = forma[0].split(";");								baseMask.graphics.beginFill(0x0000FF,1);				baseMask.graphics.moveTo(forma[0][0],forma[0][1]);				for (var b:int=1;b<forma.length;b++) {					forma[b] = forma[b].split(";");					baseMask.graphics.curveTo(forma[b][0],forma[b][1],(forma[b][2] ? forma[b][2] : forma[b][0]),(forma[b][3] ? forma[b][3] : forma[b][1]));					trace(a+"-"+b+" "+forma[b][0]+" "+forma[b][1]+" "+forma[b][2]+" "+forma[b][3])				}				baseMask.graphics.curveTo(forma[0][0],forma[0][1],(forma[0][2] ? forma[0][2] : forma[0][0]),(forma[0][3] ? forma[0][3] : forma[0][1]));				baseMask.graphics.endFill();			}		}		// END WIPES LOADER				// COLORS		public function colorizing(myAction:Array):void {			trace(myAction)			this[myAction[3]].transform.colorTransform = new ColorTransform(1, 1, 1, 1, myAction[4], myAction[5], myAction[6], 1);			//this[myAction[4]][myAction[5]] = myAction[6];			//mySetTrasform(myAction);		}		public function bkgOnOff(myAction:Array):void {			if (myAction[3] == "true") {				bkg.visible = true;			} else {				bkg.visible = false;			}		}		// END COLORS		// SEQUENCER		public function PLAY(myAction:Array):void {			cacheAsBitmap = myStopStatus=false;			if (oldTipo) {				this["PLAY"+oldTipo]();			}		}		public function STOP(myAction:Array):void {			cacheAsBitmap = myStopStatus=true;			if (oldTipo) {				trace("STOP"+oldTipo)				this["STOP"+oldTipo]();			}		}		public function REWIND(myAction:Array):void {			if (oldTipo) {				this["REWIND"+oldTipo]();			}		}		public function FORWARD(myAction:Array):void {			if (oldTipo) {				this["FORWARD"+oldTipo]();			}		}		public function HIDE(myAction:Array):void {			visible = false;		}		public function SHOW(myAction:Array):void {			visible = true;		}		// END SEQUENCER		// TRASFORM		public function chMove(myAction:Array):void {			trace("playerchMove "+myAction.join(","))			x = myAction[3];			y = myAction[4];			vid.x = myAction[5];			vid.y = myAction[6];		}		public function chScale(myAction:Array):void {			vid.scaleX = myAction[3];			vid.scaleY = myAction[4];		}		public function chRotate(myAction:Array):void {			if (cnt.rotationX != myAction[3]) cntMask.rotationX = cnt.rotationX = myAction[3];			if (cnt.rotationY != myAction[4]) cntMask.rotationY = cnt.rotationY = myAction[4];			if (cnt.rotation != myAction[5]) cntMask.rotation = cnt.rotation = myAction[5];			cntMask.cacheAsBitmap = cnt.cacheAsBitmap = false;		}		public function mRotate(myAction:Array):void {			if (vid.rotationX != myAction[3]) vid.rotationX = myAction[3];			if (vid.rotationY != myAction[4]) vid.rotationY = myAction[4];			if (vid.rotation != myAction[5]) vid.rotation = myAction[5];			vid.cacheAsBitmap = false;		}		public function myReset(myAction:Array):void {			x = 0;			y = 0;			vid.x = w/2;			vid.y = h/2;			vid.rotation = 0;			vid.scaleX = Preferences.pref.monObj.dScaleX;			vid.scaleY = Preferences.pref.monObj.dScaleY;		}		public function chFlipH(myAction:Array):void {			vid.scaleX = -vid.scaleX;		}		public function chFlipV(myAction:Array):void {			vid.scaleY = -vid.scaleY;		}		// END TRASFORM		public function changeBlend(myAction:Array):void {			blendMode = myAction[3];		}		public function setMatrix(myAction:Array):void {			var mat:ColorMatrix=new ColorMatrix();			if (myAction[11]>0) {				trace("threshold set "+Number(myAction[11]))				mat.threshold(Number(myAction[11]));				//mat.threshold(0,0);			} else {				trace("threshold reset")				mat.reset();			}			mat.adjustHue(Number(myAction[7]));			mat.adjustSaturation(Number(myAction[8]));			mat.adjustContrast(Number(myAction[9]));			mat.adjustBrightness(Number(myAction[10]));			/*			*/			mat.setChannels(Number(myAction[3]),Number(myAction[4]),Number(myAction[5]),Number(myAction[6]));			var cm:ColorMatrixFilter=new ColorMatrixFilter(mat.matrix);			filters = new Array(cm);					}		public function eject(myAction:Array):void {			trace("EJCET"+oldTipo)			if (oldTipo) {				this["RESET"+oldTipo]();			}			oldTipo = undefined;		}		public function placeObjectIn3D(myAction:Array):void {			/*trace("vid.alpha "+vid.alpha)			trace("vid.x "+vid.x)			trace("vid.y "+vid.y)			trace("vid.scale "+vid.scaleY)			trace("scalemask "+cntMask.scaleY)			trace("\\alpha "+myAction[3])			trace("\\x "+myAction[4])			trace("\\y "+myAction[5])			trace("\\scale "+myAction[6])			trace("\\scalemask "+myAction[7])			trace("placeObjectIn3DDDDDD "+myAction[4]+" "+myAction[5])			*/			vid.alpha = myAction[3];			trace("vid.scale "+ch +" " +myAction[8])			if (stereo=="left") {				vid.x = myAction[5];				trace("vid.x left "+ch +" " +myAction[5])			} else if (stereo=="right") {				vid.x = myAction[6];				trace("vid.x right "+ch +" " +myAction[6])			} else {				vid.x = myAction[4];			}			vid.y = myAction[7];			vid.scaleX = vid.scaleY=myAction[8];			//cntMask.scaleX = cntMask.scaleY = bkg.scaleX = bkg.scaleY=myAction[7];			/*trace("vid.alpha "+vid.alpha)			trace("vid.x "+vid.x)			trace("vid.y "+vid.y)			trace("vid.scale "+vid.scaleY)			trace("scalemask "+cntMask.scaleY)*/		}		public function mySwapDepth(myAction:Array):void {			parent.setChildIndex(this,parseFloat(myAction[3]));		}		public function myHQ(myAction:Array):void {			stage.quality = StageQuality[myAction[3]];			trace(stage.quality)		}		public function ALIGNtxt(myAction:Array):void {			if (myTxt) {				txtKS.align = myAction[3];				if (txtKS.align == "right") {					swfLoader.content["lab"].x = (-(swfLoader.x+(w/2))/swfLoader.scaleX)+(w/swfLoader.scaleX)-swfLoader.content["lab"].width;				} else if (txtKS.align == "left") {					swfLoader.content["lab"].x = -(swfLoader.x+(w/2))/swfLoader.scaleX;				} else {					swfLoader.content["lab"].x = (400-swfLoader.content["lab"].width)/2;				}				swfLoader.content["lab"].defaultTextFormat = txtKS			}		}		public function FONTtxt(myAction:Array):void {			myFont = myAction[3]			setFont()					}		private function setFont():void {			if (myFont == "ReaderFont") {				swfLoader.content["setDefaultFont"]();			} else {				txtKS.font = myFont;				swfLoader.content["lab"].embedFonts = false;				swfLoader.content["lab"].defaultTextFormat = txtKS			}		}		private function RESETtxt():void {			RESETswf();		}		private function FORWARDtxt():void {			swfLoader["forwardTxt"]();		}		private function REWINDtxt():void {			swfLoader["rewindTxt"]();		}		private function STOPtxt():void {			swfLoader["stopTxt"]();		}		private function PLAYtxt():void {			swfLoader["playTxt"]();		}		//		public function seqUpdater(myAction:Array):void {			if (!seqPattern) {				seqPattern = new Array("NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL","NULL");			}			clearInterval(seqInt);			seqAct();			seqInt = setInterval(seqAct, myAction[3]);		}		public function setSeqPattern(myAction:Array):void {			seqPattern = myAction.splice(3, 16);			//trace(seqPattern);		}		private function seqAct():void {			if (seqPos>14) {				seqPos = 0;			} else {				seqPos++;			}			if (masterSeq) {				for (var a:int=0;a<Preferences.pref.nCh;a++) {					if (Preferences.monitorTrgt.levels["ch_"+a].seqStatus && Preferences.monitorTrgt.levels["ch_"+a].seqPattern[seqPos]!="NULL") Preferences.monitorTrgt.levels["ch_"+a][Preferences.monitorTrgt.levels["ch_"+a].seqPattern[seqPos]](null);				}			} else {				if (seqPattern[seqPos]!="NULL") this[seqPattern[seqPos]](null);			}			//trace(seqPos+": "+seqPattern[seqPos])			if (seqPattern[seqPos]!="NULL") {				this[seqPattern[seqPos]](null);			}		}		public function seqManager(myAction:Array):void {			seqStatus = myAction[3];		}		public function setMasterTap(myAction:Array):void {			masterSeq = myAction[3];		}		public function removeSeq(myAction:Array):void {			clearInterval(seqInt);		}	}}