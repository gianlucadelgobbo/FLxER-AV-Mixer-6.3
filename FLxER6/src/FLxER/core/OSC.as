package FLxER.core {    import flash.display.Sprite;    import flash.events.Event;    import flash.net.URLLoader;    import flash.net.URLRequest;    import flash.utils.getDefinitionByName;    import flash.xml.XMLDocument;        import org.tuio.connectors.UDPConnector;    import org.tuio.osc.IOSCConnectorListener;    import org.tuio.osc.OSCMessage;    import org.tuio.osc.OSCPacket;    public class OSC extends Sprite implements IOSCConnectorListener {        private var oscSocket:UDPConnector;        //private const OSCSERVER:String = "172.20.10.2";        private const OSCSERVER:String = Preferences.pref.osc.server;        private const PORT:int = Preferences.pref.osc.port;		private var myLoader:URLLoader;		private var OSCmapObject:Object;		private var c:int;		public function OSC():void {			myLoader = new URLLoader(new URLRequest(Preferences.basepath+Preferences.pref.osc.map.url));			myLoader.addEventListener("complete", firstStartup);			myLoader.addEventListener("ioError", xmlNotLoaded);			//c = setInterval(bella,2000);		}		private function bella():void {			trace("Data not loaded.");		}		private function xmlNotLoaded(event:Event):void {			trace("Data not loaded."+event);		}		private function firstStartup(event:Event):void {			var OSCmap:XMLDocument = new XMLDocument();			OSCmap.ignoreWhite = true;			OSCmap.parseXML(myLoader.data);			OSCmapObject = new Object;			for (var a:int=0; a<OSCmap.childNodes[0].childNodes.length;a++) {				if (!OSCmapObject[OSCmap.childNodes[0].childNodes[a].attributes.oscAddress]) OSCmapObject[OSCmap.childNodes[0].childNodes[a].attributes.oscAddress] = new Object();				OSCmapObject[OSCmap.childNodes[0].childNodes[a].attributes.oscAddress].fnz = OSCmap.childNodes[0].childNodes[a].attributes.fnz;				if (OSCmap.childNodes[0].childNodes[a].attributes.val) OSCmapObject[OSCmap.childNodes[0].childNodes[a].attributes.oscAddress].val = OSCmap.childNodes[0].childNodes[a].attributes.val.split(",");				OSCmapObject[OSCmap.childNodes[0].childNodes[a].attributes.oscAddress].ch = OSCmap.childNodes[0].childNodes[a].attributes.ch;				OSCmapObject[OSCmap.childNodes[0].childNodes[a].attributes.oscAddress].direct = OSCmap.childNodes[0].childNodes[a].attributes.direct ? OSCmap.childNodes[0].childNodes[a].attributes.direct : 0;				/*				if (a>0){					Preferences.myCameras.childNodes[0].appendChild(Preferences.myCameras.childNodes[0].childNodes[0].cloneNode(true));				}				Preferences.myCameras.childNodes[0].childNodes[a].attributes.m = cam[a]				Preferences.myCameras.childNodes[0].childNodes[a].attributes.val = a				*/			}			/*			for (var i in OSCmapObject) {				trace("OSCmapObject."+i+" = "+OSCmapObject[i]);				for (var j in OSCmapObject[i]) {					trace("	"+j+" = "+OSCmapObject[i][j]);				}			}			*/			connect();		}		public function connect():void {			trace("connect");            try{                    oscSocket = new UDPConnector(OSCSERVER,PORT);                oscSocket.addListener(this);                trace(this,"OSC ready");				Preferences.OSCactive = true;            } catch(e:Error) {				trace(e);				handleOnError(e);				Preferences.OSCactive = false;			}   		}		private function handleOnError(e:Error):void {			trace("handleOnError "+e)			Preferences.myGlobalCtrl.puls22.myStatus_swap();			//trace(e.getStackTrace());			//oscSocket.connected = false;		}        public function close():void{			oscSocket.close();		}        public function acceptOSCPacket(oscPacket:OSCPacket):void{            //handle OSC here            var messagee:OSCMessage = oscPacket as OSCMessage;            //trace(messagee.getPacketInfo());            //trace(messagee.getPacketInfo());            //trace(messagee.toString());            //trace(messagee.address);            //trace(messagee.arguments);            //trace(messagee.arguments[0]+1);            //trace(stage.stageWidth);			//var arg = messagee.arguments.split(",");            //var messagee:OSCMessage = oscPacket as OSCMessage;            //trace(messagee.argumentArray);            //trace("message from :",messagee.address,"at",new Date());           	//for(var i:int = 0; i < messagee.arguments.length; i++) trace("\targs["+i+"]",messagee.arguments[i]);			/*			var xmlIn:String = event.data;			trace("handleIncoming "+xmlIn)			var tmp:Array = xmlIn.toString().split(",");			var myCh:uint;			if (!tmp[2] || tmp[2] == "auto" || isNaN(parseInt(tmp[2]))) {				myCh = Preferences.pref.ch;			} else {				myCh = parseInt(tmp[2]);			}				trace("tmp[0] "+tmp[0]);			trace("tmp[1] "+tmp[1]);			trace("tmp[2] "+tmp[2]);			*/			/*			*/			//trace("OSCmapObject[messagee.address] "+OSCmapObject[messagee.address]);			var myCh:uint;			if (OSCmapObject[messagee.address]) {				if (!OSCmapObject[messagee.address].ch || OSCmapObject[messagee.address].ch == "auto" || isNaN(parseInt(OSCmapObject[messagee.address].ch))) {					myCh = Preferences.pref.ch;				} else {					myCh = parseInt(OSCmapObject[messagee.address].ch);				}				//trace("messagee.arguments[0] "+messagee.arguments[0]);				//trace("OSCmapObject[messagee.address].val[0] "+OSCmapObject[messagee.address].val[0]);				//trace("OSCmapObject[messagee.address].val[1] "+OSCmapObject[messagee.address].val[1]);				var val:Number;				if (messagee.arguments.length == 1 && OSCmapObject[messagee.address].val && OSCmapObject[messagee.address].val.length==2) {					val = ((OSCmapObject[messagee.address].val[1]-OSCmapObject[messagee.address].val[0])*messagee.arguments[0])-OSCmapObject[messagee.address].val[0];				} else {					val = parseInt(messagee.arguments[0]);				}				//debug.text = val;				if (OSCmapObject[messagee.address].direct) {					if (Preferences.monitorOut is Output && Preferences.monitorOut.levels["ch_"+OSCmapObject[messagee.address].ch].swfLoader.content[OSCmapObject[messagee.address].fnz] is Function) {						Preferences.monitorOut.levels["ch_"+OSCmapObject[messagee.address].ch].swfLoader.content[OSCmapObject[messagee.address].fnz](val);					} else if (Preferences.monitorOut is OutputBMP && Preferences.monitorTrgt.levels["ch_"+OSCmapObject[messagee.address].ch].swfLoader.content[OSCmapObject[messagee.address].fnz] is Function) {						Preferences.monitorTrgt.levels["ch_"+OSCmapObject[messagee.address].ch].swfLoader.content[OSCmapObject[messagee.address].fnz](val);					}				} else {					Preferences.myKeyboardIn.myMidi(OSCmapObject[messagee.address].fnz, val, myCh);				}			}		}		private function handleConnect(event):void {			trace("handleConnect"+event);			//mySocket.connected = true;		}		private function handleClose():void {			//mySocket.connected = false;		}		/*function parseMessages(node):void {			if (node.nodeName == "MESSAGE") {				var name = node.attributes.NAME;				child = node.firstChild;				if (name == "control1") {					_root.myToolbarTop.palettes.Trasform.myTrgt.myDragOSC("r,CM,CMT,rb", parseFloat(child.attributes.VALUE));				}				if (name == "control2") {					_root.myToolbarTop.palettes.Trasform.myTrgt.myDragOSC("g,CM,CMT,gb", parseFloat(child.attributes.VALUE));				}				if (name == "control3") {					_root.myToolbarTop.palettes.Trasform.myTrgt.myDragOSC("b,CM,CMT,bb", parseFloat(child.attributes.VALUE));				}				if (name == "sy") {					_root.sy = child.attributes.VALUE;				}				if (name == "zx") {					_root.zx = child.attributes.VALUE;				}				if (name == "zy") {					_root.zy = child.attributes.VALUE;				}				// loop over the arguments of the message 				for (var child = node.firstChild; child != null; child=child.nextSibling) {					if (child.nodeName == "ARGUMENT") {					}				}			} else {				// look recursively for a message node				for (var child = node.firstChild; child != null; child=child.nextSibling) {					parseMessages(child);				}			}		}		function sendOSC(name, arg, destAddr, destPort) {			mySocket.send(xmlOut);		}*/	}}