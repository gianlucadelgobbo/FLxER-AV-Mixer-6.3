package FLxER.modules.MappingSVG {	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.xml.XMLDocument;		import FLxER.modules.MappingSVG.MapPoint;	import FLxER.modules.MappingSVG.MySprite;  	public class MappingSVGDrawer extends Sprite {		//		private var background:Sprite		private var shapesArea:Sprite		private var handlesArea:Sprite;				private var shapesAcnt:Array;		private var shapesA:Array;		private var handlesAcnt:Array;		public var currentShape:int;		public static var w:uint;		public static var h:uint;		private var KeyboardSHIFT:Boolean = false;		private var myCol:String = "0000FF";		public var showFill:Boolean = true;		private var drawermode:String;		private var oldCurrentShapePos:Array;				private var trgt:MappingSVGStarter;		public function MappingSVGDrawer(t:MappingSVGStarter) {			trgt = t;			w = Preferences.monitorTrgt.w;			h = Preferences.monitorTrgt.h;			addEventListener(Event.ADDED_TO_STAGE, init);		}		private function init(event:Event):void {			if (!handlesArea) {				background = new Sprite();				background.x = w/2;				background.y = h/2;				background.graphics.beginFill(0xFFFFFF,0);				background.graphics.moveTo(-w/2,-h/2);				background.graphics.lineTo(w/2,-h/2);				background.graphics.lineTo(w/2,h/2);				background.graphics.lineTo(-w/2,h/2);				background.graphics.lineTo(-w/2,-h/2);				background.graphics.endFill();				this.addChild(background);				shapesArea = new Sprite();				shapesArea.name = "shapesArea";				shapesArea.x = w/2;				shapesArea.y = h/2;				this.addChild(shapesArea);				//				handlesArea = new Sprite();				handlesArea.name = "handlesArea";				handlesArea.x = w/2;				handlesArea.y = h/2;				this.addChild(handlesArea);				//			}			shapesA = new Array();			shapesAcnt = new Array();			handlesAcnt = new Array();			currentShape = 0;		}		public function setDrawerMode(dm:String):void {			var a:int			var b:int			switch(drawermode) {				case "pen" :					background.removeEventListener(MouseEvent.MOUSE_DOWN, myDrawer);					for (a=0;a<handlesAcnt.length;a++) {						for (b=0;b<handlesAcnt[a].numChildren;b++) {							if (handlesAcnt[a].getChildAt(b)) handlesAcnt[a].getChildAt(b).disablePenMode();						}					}				break;				case "penDel" :					for (a=0;a<handlesAcnt.length;a++) {						for (b=0;b<handlesAcnt[a].numChildren;b++) {							if (handlesAcnt[a].getChildAt(b)) handlesAcnt[a].getChildAt(b).disablePenDelMode();						}					}				break;				case "penEdit" :					for (a=0;a<handlesAcnt.length;a++) {						for (b=0;b<handlesAcnt[a].numChildren;b++) {							if (handlesAcnt[a].getChildAt(b)) handlesAcnt[a].getChildAt(b).disablePenEditMode();						}					}				break;			}			drawermode = dm;			switch(drawermode) {				case "pen" :					background.addEventListener(MouseEvent.MOUSE_DOWN, myDrawer);					for (a=0;a<handlesAcnt.length;a++) {						for (b=0;b<handlesAcnt[a].numChildren;b++) {							if (handlesAcnt[a].getChildAt(b)) handlesAcnt[a].getChildAt(b).enablePenMode();						}					}				break;				case "penDel" :					for (a=0;a<handlesAcnt.length;a++) {						for (b=0;b<handlesAcnt[a].numChildren;b++) {							if (handlesAcnt[a].getChildAt(b)) handlesAcnt[a].getChildAt(b).enablePenDelMode();						}											}				break;				case "penEdit" :					for (a=0;a<handlesAcnt.length;a++) {						for (b=0;b<handlesAcnt[a].numChildren;b++) {							if (handlesAcnt[a].getChildAt(b)) handlesAcnt[a].getChildAt(b).enablePenEditMode();						}					}				break;			}			currentShape = -1;		}		private function myDrawer(event:Event):void {			trace("myDrawer"+currentShape)			if (!shapesA[currentShape]) {				shapesA.push(new Array());				currentShape = (shapesA.length ? shapesA.length-1 : 0);				shapesA[currentShape]["points"] = new Array();				shapesA[currentShape]["is_close"] = false;				//				shapesAcnt[currentShape] = new MySprite();				handlesAcnt[currentShape] = new Sprite();				shapesArea.addChild(shapesAcnt[currentShape]);				handlesArea.addChild(handlesAcnt[currentShape]);			}			var p:Array = new Array(handlesArea.mouseX,handlesArea.mouseY,handlesArea.mouseX,handlesArea.mouseY);			shapesA[currentShape]["points"].push(p);			handlesAcnt[currentShape].addChildAt(new MapPoint(p,currentShape,shapesA[currentShape]["points"].length-1, myCol, updatePath, true, getCurrentShape,deletePoint,drawermode),shapesA[currentShape]["points"].length-1);		}		private function updatePath(shape,id,a,b,c,d):void {			currentShape = shape;			trace("shape "+shape)			trace("id "+id)			shapesA[shape]["points"][id][0] = a;			shapesA[shape]["points"][id][1] = b;			shapesA[shape]["points"][id][2] = c;			shapesA[shape]["points"][id][3] = d;			drawShapes(currentShape);			if (id==0 && shapesA[shape]["points"].length>1) {				shapesA[currentShape]["is_close"] = true;				currentShape = -1;				stage.focus = stage;			}		}		public function getCurrentShape():Number {			trace("getCurrentShape "+currentShape);			return currentShape;		}		public function deletePoint(a,ii):void {			trace("deletePoint "+a+" "+ii)			for (var b:int=0;b<shapesA[a]["points"].length;b++) {				if (this.contains(shapesArea)) handlesAcnt[a].removeChildAt(0);				shapesAcnt[a].graphics.clear();			}			shapesA[a]["points"].splice(ii,1);			drawHandles(a);			drawShapes(a);			stage.focus = stage;			currentShape = -1		}		private function drawShapes(a):void {			trace("drawShapes")			if (shapesAcnt[a] is MySprite) {				shapesAcnt[a].graphics.clear();			} else {				shapesAcnt[a] = new MySprite();			}			if (showFill) shapesAcnt[a].graphics.beginFill(uint("0x"+myCol),.5);			shapesAcnt[a].graphics.lineStyle(1, uint("0x"+myCol));			shapesAcnt[a].graphics.moveTo(shapesA[a]["points"][0][2], shapesA[a]["points"][0][3]);			for (var b:int=1;b<shapesA[a]["points"].length;b++) {				shapesAcnt[a].graphics.curveTo(shapesA[a]["points"][b][0], shapesA[a]["points"][b][1], shapesA[a]["points"][b][2], shapesA[a]["points"][b][3]);			}			if (shapesA[a]["is_close"]) shapesAcnt[a].graphics.curveTo(shapesA[a]["points"][0][0], shapesA[a]["points"][0][1], shapesA[a]["points"][0][2], shapesA[a]["points"][0][3]);			shapesAcnt[a].graphics.endFill();			shapesArea.addChild(shapesAcnt[a]); 		}		public function drawHandles(a):void {			/*			if (handlesAcnt[a] is Sprite) {				handlesAcnt[a].graphics.clear();			} else {				handlesAcnt[a] = new Sprite();			}			*/			handlesAcnt[a] = new Sprite();			handlesArea.addChild(handlesAcnt[a]);			for (var b:int=0;b<shapesA[a]["points"].length;b++) {				var tt:MapPoint = new MapPoint(shapesA[a]["points"][b],a,b, myCol, updatePath, false,getCurrentShape,deletePoint,drawermode)				handlesAcnt[a].addChildAt(tt,b);			}		}		public function setCol(c):void {			myCol = c;			trace("setCol"+myCol);			clearStage()			drawMap()		}		public function clearAll():void {			clearStage();			shapesA = new Array();			trace("clearAllnnnnnnnnnn");		}		public function saveShapes():void {			trace("saveShapesnnnnnnnnnn");			var xmlTmp:String = "<g>\n";			for (var a:int=0;a<shapesA.length;a++) {				xmlTmp+="	<path fill='#000000' stroke='none' d='M"+shapesA[a]["points"][0][2]+","+shapesA[a]["points"][0][3];				for (var b:int=1;b<shapesA[a]["points"].length;b++) {					trace("gggg "+a+" "+b)					xmlTmp+="Q"+shapesA[a]["points"][b][0];					xmlTmp+=","+shapesA[a]["points"][b][1];					xmlTmp+=","+shapesA[a]["points"][b][2];					xmlTmp+=","+shapesA[a]["points"][b][3];				}				//xmlTmp+="Q"+shapesA[a]["points"][0][0];				//xmlTmp+=","+shapesA[a]["points"][0][1];				//xmlTmp+=","+shapesA[a]["points"][0][2];				//xmlTmp+=","+shapesA[a]["points"][0][3];				xmlTmp+="' />\n";			}			xmlTmp+="</g>\n";			trgt.saveShapesAct(xmlTmp);					}		public function editMap(str):void {			clearAll();			var xmlMap:XMLDocument = new XMLDocument();			xmlMap.ignoreWhite = true;			xmlMap.parseXML(str);			for (var a:int=0;a<xmlMap.childNodes[0].childNodes[0].childNodes.length;a++) {				shapesA.push(new Array());				shapesA[a]["points"] = new Array();				var forma:Array = xmlMap.childNodes[0].childNodes[0].childNodes[a].attributes.d.substring(1).split("Q");				for (var b:int=0;b<forma.length;b++) {					forma[b] = forma[b].split(",");					var punto:Array = new Array(forma[b][0],forma[b][1],(forma[b][2] ? forma[b][2] : forma[b][0]),(forma[b][3] ? forma[b][3] : forma[b][1]))					shapesA[a]["points"].push(punto);				}			}			drawMap();		}		public function drawMap():void {			//setEditMap();			for (var a:int=0;a<shapesA.length;a++) {				drawHandles(a);				drawShapes(a);			}		}		public function clearStage():void {			trace("clearStage shapesA.length "+shapesA.length)			for (var a:int=0;a<shapesA.length;a++) {				trace("clearStage shapesA["+a+"][\"points\"].length "+shapesA[a]["points"].length)				trace("clearStage handlesAcnt[a].length "+handlesAcnt[a].numChildren)				for (var b:int=0;b<shapesA[a]["points"].length;b++) {					trace("clearStage "+a+" "+b)					trace("clearStage"+handlesAcnt[a].getChildAt(0))					if (handlesAcnt[a].getChildAt(0) is Sprite) handlesAcnt[a].removeChildAt(0);				}				//if (shapesAcnt[a] is Sprite) 				shapesAcnt[a].graphics.clear();				//handlesArea.removeChild(handlesAcnt[a]);			}			shapesAcnt = new Array();			handlesAcnt = new Array();			currentShape = -1		}/*		private function updateCurrentShape():void {		drawShapes(currentShape);		}		private function myMove(event:Event):void {			trace(event.currentTarget);			//draggedShapeX = event.currentTarget.x;			//draggedShapeY = event.currentTarget.y;			currentShape = event.currentTarget.id;			oldCurrentShapePos = [shapesAcnt[currentShape].x,shapesAcnt[currentShape].y];			handlesAcnt[currentShape].startDrag(false);			event.currentTarget.startDrag(false);			this.addEventListener(Event.ENTER_FRAME, myMoveHandlers);					}		private function myMoveUP(event:Event):void {			event.currentTarget.stopDrag();			this.removeEventListener(Event.ENTER_FRAME, myMoveHandlers);			for (var b:int=0;b<shapesA[currentShape]["points"].length;b++) {				shapesA[currentShape]["points"][b][0] += handlesAcnt[currentShape].x;				shapesA[currentShape]["points"][b][1] += handlesAcnt[currentShape].y;				shapesA[currentShape]["points"][b][2] += handlesAcnt[currentShape].x;				shapesA[currentShape]["points"][b][3] += handlesAcnt[currentShape].y;			}			handlesAcnt[currentShape].x = 0;			handlesAcnt[currentShape].y = 0;			drawMap();			for (var a:int=0;a<shapesAcnt.length;a++) {				shapesAcnt[a].addEventListener(MouseEvent.MOUSE_DOWN, myMove);				shapesAcnt[a].addEventListener(MouseEvent.MOUSE_UP, myMoveUP);			}		}		private function myMoveHandlers(event:Event):void {			handlesAcnt[currentShape].x = shapesAcnt[currentShape].x			handlesAcnt[currentShape].y = shapesAcnt[currentShape].y		}		public function newShape():void {			trace("newShapennnnnnnnnnnn");			currentShape = -1		}		private function myMouseUp(event:Event):void {			//shapesArea.addEventListener(MouseEvent.MOUSE_DOWN, myDrawer);		}		public function setUseMap():void {			if (this.contains(shapesArea)) this.removeChild(shapesArea);			if (this.contains(handlesArea)) this.removeChild(handlesArea);		}		public function setEditMap():void {			trace("editMapeditMapeditMapeditMapeditMapeditMap")			if (!this.contains(shapesArea)) this.addChild(shapesArea);			if (!this.contains(handlesArea)) this.addChild(handlesArea);		}		*/	}}