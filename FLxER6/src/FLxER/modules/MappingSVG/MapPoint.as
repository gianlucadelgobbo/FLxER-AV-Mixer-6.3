package FLxER.modules.MappingSVG {//	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;
	public class MapPoint extends Sprite{		private var currentShape:int;		private var myId:int;		private var fnz:Function;		private var shape:Sprite;		private var handle:Sprite;		private var line:Sprite;		private var firstTime:Boolean;		private var getCurrentShape:Function;		private var deletePoint:Function;		private var getKeyboardSHIFT:Function		private var myCol:String		private var mode:String		public function MapPoint(p:Array,a:uint,b:uint,col:String,f:Function,manualDraw:Boolean,i:Function,d:Function,drawermode:String) {			trace("MapPointeeeeeeeeeee "+b)			x = p[2];			y = p[3];			firstTime = false;			currentShape = a;			myId = b;			myCol = col;			fnz = f;			getCurrentShape = i;			deletePoint = d;			mode = drawermode;			shape = new Sprite();			shape.graphics.beginFill(uint("0x"+myCol),1);			var l:uint = 9;			shape.graphics.moveTo(-l,-l);			shape.graphics.lineTo(l,-l);			shape.graphics.lineTo(l,l);			shape.graphics.lineTo(-l,l);			shape.graphics.lineTo(-l,-l);            shape.graphics.endFill();			this.addChild(shape);			if ((manualDraw && myId) || (p[0]-p[2])+(p[1]-p[3]) != 0) {				handle = new Sprite();				handle.x = p[0]-p[2];				handle.y = p[1]-p[3];				line = new Sprite();								handle.graphics.beginFill(uint("0x"+myCol),1);				handle.graphics.drawCircle(0, 0, l);				handle.graphics.endFill();				handle.addEventListener(MouseEvent.MOUSE_UP, penEditModeHandleStopDrag);				this.addChild(line);				this.addChild(handle);				if (manualDraw && myId) {					handle.startDrag(true);					this.addEventListener(Event.ENTER_FRAME, updatePath);				}				if (handle.x+handle.y!=0) {					line.graphics.lineStyle(1, parseInt("0x"+myCol));					line.graphics.moveTo(0, 0);					line.graphics.lineTo(handle.x, handle.y);				}			}			switch(mode) {				case "pen" :					enablePenMode();					break;				case "penDel" :					enablePenDelMode();					break;				case "penEdit" :					enablePenEditMode();					break;			}		}		public function enablePenMode():void {			mode = "draw";			if (myId == 0) {				shape.addEventListener(MouseEvent.MOUSE_OVER, penModeShapeMouseOver);				shape.addEventListener(MouseEvent.MOUSE_OUT,  penModeShapeMouseOut);				shape.addEventListener(MouseEvent.MOUSE_DOWN,   penEditModeShapeMouseUp);				shape.buttonMode = true;			}		}		public function disablePenMode():void {			mode = "draw";			if (myId == 0) {				trace("disablePenMode");				shape.removeEventListener(MouseEvent.MOUSE_OVER, penModeShapeMouseOver);				shape.removeEventListener(MouseEvent.MOUSE_OUT,  penModeShapeMouseOut);				shape.removeEventListener(MouseEvent.MOUSE_DOWN,   penEditModeShapeMouseUp);				shape.buttonMode = false;			}		}		public function enablePenEditMode():void {			shape.addEventListener(MouseEvent.MOUSE_DOWN, penEditModeShapeMouseDown);			shape.addEventListener(MouseEvent.MOUSE_UP,   penEditModeShapeMouseUp);			shape.buttonMode = true;			if (handle) {				handle.addEventListener(MouseEvent.MOUSE_DOWN, penEditModeHandleMouseDown);				handle.addEventListener(MouseEvent.MOUSE_UP,   penEditModeHandleStopDrag);				handle.buttonMode = true;							}		}		public function disablePenEditMode():void {			shape.removeEventListener(MouseEvent.MOUSE_DOWN, penEditModeShapeMouseDown);			shape.removeEventListener(MouseEvent.MOUSE_UP,   penEditModeShapeMouseUp);			shape.buttonMode = false;			if (handle) {				handle.removeEventListener(MouseEvent.MOUSE_DOWN, penEditModeHandleMouseDown);				handle.removeEventListener(MouseEvent.MOUSE_UP,   penEditModeHandleStopDrag);				handle.buttonMode = false;			}		}		public function penEditModeShapeMouseDown(event:Event):void {			trace("penEditModeShapeMouseDown "+event)			this.startDrag(true);			this.addEventListener(Event.ENTER_FRAME, updatePath);		}		private function penModeShapeMouseDown(event:Event):void {			trace("penModeShapeMouseDown "+event)			if (myId == 0 && getCurrentShape()==currentShape) {				updatePath(event);			}		}		private function penEditModeShapeMouseUp(event:Event):void {			trace("penEditModeShapeMouseUp "+event)			this.removeEventListener(Event.ENTER_FRAME, updatePath);			this.stopDrag();			updatePath(event);			disablePenMode();			Preferences.myAlt.stoppa();		}		public function enablePenDelMode():void {			trace("enablePenDelMode ")			shape.addEventListener(MouseEvent.MOUSE_DOWN, penDelModeMouseDown);			shape.addEventListener(MouseEvent.MOUSE_OVER, penDelModeMouseOver);			shape.addEventListener(MouseEvent.MOUSE_OUT, penModeShapeMouseOut);			shape.buttonMode = true;		}		public function disablePenDelMode():void {			shape.removeEventListener(MouseEvent.MOUSE_DOWN, penDelModeMouseDown);			shape.removeEventListener(MouseEvent.MOUSE_OVER, penDelModeMouseOver);			shape.removeEventListener(MouseEvent.MOUSE_OUT, penModeShapeMouseOut);			shape.buttonMode = false;		}		private function penDelModeMouseDown(event:Event):void {			deletePoint(currentShape,myId)		}		private function penDelModeMouseOver(event:Event):void {			Preferences.myAlt.avvia("Delete");		}		private function penModeShapeMouseOver(event:Event):void {			trace("penModeShapeMouseOver "+getCurrentShape()+" - "+currentShape+" - ");			if (myId == 0 && getCurrentShape()==currentShape) {				Preferences.myAlt.avvia("Close shape");			}		}		private function penModeShapeMouseOut(event:Event):void {			Preferences.myAlt.stoppa();		}		private function penEditModeHandleMouseDown(event:Event):void {			//handle.startDrag(true, new Rectangle(-x-(FlxerDrawerPlugIn.w/2), -y-(FlxerDrawerPlugIn.h/2), FlxerDrawerPlugIn.w,FlxerDrawerPlugIn.h));			handle.startDrag(true);			this.addEventListener(Event.ENTER_FRAME, updatePath);		}		private function penEditModeHandleStopDrag(event:Event):void {			trace("penEditModeHandleStopDrag"+event)			this.removeEventListener(Event.ENTER_FRAME, updatePath);			handle.stopDrag();			updatePath(event);			if (Math.abs(handle.x)<3 && Math.abs(handle.y)<3) {				this.removeChild(handle);				this.removeChild(line);			}			handle.removeEventListener(MouseEvent.MOUSE_UP, penEditModeHandleStopDrag);			handle.buttonMode = false;		}		/*		private function stopDragHandle(event:Event):void {			if (myId != 0 || firstTime) {				trace("stopDragHandle"+event)				this.removeEventListener(Event.ENTER_FRAME, updatePath);				handle.stopDrag();				updatePath(event);				if (Math.abs(handle.x)<3 && Math.abs(handle.y)<3) {					this.removeChild(handle);					this.removeChild(line);				}			}			handle.removeEventListener(MouseEvent.MOUSE_UP, stopDragHandle);			firstTime = true;			Preferences.myAlt.stoppa();		}		*/		private function updatePath(event:Event):void {			if (handle && handle.x+handle.y!=0) {				line.graphics.clear();				line.graphics.lineStyle(1, parseInt("0x"+myCol));				line.graphics.moveTo(0, 0);				line.graphics.lineTo(handle.x, handle.y);				fnz(currentShape,myId, x+handle.x,y+handle.y, x, y);				trace("updatePath si handle"+myId)			} else {				fnz(currentShape,myId, x, y, x, y);				trace("updatePath no handle"+myId)			}		}	}}